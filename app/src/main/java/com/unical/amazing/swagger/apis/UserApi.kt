/**
 * OpenAPi NerdWarehouse
 * OpenApi documentation for Spring Security
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import android.content.Context
import com.unical.amazing.R
import com.unical.amazing.model.settings.HOST_URL
import com.unical.amazing.swagger.models.UserUpdDto
import io.swagger.client.models.NewUserDto
import io.swagger.client.models.UserDto
import io.swagger.client.infrastructure.*
import okhttp3.*
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import java.io.FileInputStream
import java.io.IOException
import java.security.KeyStore
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManagerFactory
import javax.net.ssl.X509TrustManager


class UserApi(context: Context, // Aggiungi il Context come parametro
              basePath: String = "https://$HOST_URL:8443/"
) : ApiClient(basePath, createSecureClient(context, R.raw.truststore,"progettoea")) {

    private val Context = context

    /**
     * 
     * 
     * @param body  
     * @return NewUserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun addUser(body: NewUserDto): NewUserDto {
        val localVariableBody: kotlin.Any? = body
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/v1/users"
        )
        val response = request<NewUserDto>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NewUserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * this is the list of user
     * Get endpoint for user
     * @param email  
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findByEmail(email: kotlin.String): UserDto {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v1/users/{email}".replace("{" + "email" + "}", "$email")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }




//UTILIZZATO PER AREA PERSONALE UTENTE
    @Suppress("UNCHECKED_CAST")
    fun account(token: String): UserDto {
        val headers = mapOf("Authorization" to "Bearer $token")
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/auth/me",
            headers = headers
            )
        val response = request<UserDto>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }




    fun update(token: String, body: UserUpdDto): Int {
        val gson = Gson()

        // Converti il corpo in JSON
        val jsonBody = gson.toJson(body)
        val requestBody = RequestBody.create("application/json".toMediaType(), jsonBody)

        // Carica il tuo truststore (assumi che il percorso sia configurato correttamente)
        val client = createHttpClientWithTrustStore(Context,"progettoea")

        // Costruisci la richiesta
        val request = Request.Builder()
            .url("https://$HOST_URL:8443/auth/update")  // Usa HTTPS
            .post(requestBody)
            .addHeader("Authorization", "Bearer $token")
            .build()

        try {
            // Esegui la richiesta
            client.newCall(request).execute().use { response ->
                return when (response.code) {
                    200 -> 200
                    in 100..199 -> throw IOException("Informational response code: ${response.code}")
                    in 300..399 -> throw IOException("Redirection response code: ${response.code}")
                    in 400..499 -> throw ClientException(response.body?.string() ?: "Client error")
                    in 500..599 -> throw ServerException(response.message ?: "Server error")
                    else -> throw IOException("Unexpected response code: ${response.code}")
                }
            }
        } catch (e: IOException) {
            throw e
        }
    }




    private fun createHttpClientWithTrustStore(context: Context, trustStorePassword: String): OkHttpClient {
        val trustStore = KeyStore.getInstance("BKS")

        // Usa Resources.openRawResource() per ottenere l'InputStream
        context.resources.openRawResource(R.raw.truststore).use { inputStream ->
            trustStore.load(inputStream, trustStorePassword.toCharArray())
        }

        val trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
        trustManagerFactory.init(trustStore)
        val trustManagers = trustManagerFactory.trustManagers

        val sslContext = SSLContext.getInstance("TLS")
        sslContext.init(null, trustManagers, null)

        val trustManager = trustManagers[0] as X509TrustManager

        return OkHttpClient.Builder()
            .sslSocketFactory(sslContext.socketFactory, trustManager)
            .hostnameVerifier { _, _ -> true }
            .build()
    }




}
